# -*- coding: utf-8 -*-
"""lab2-bst-avl-rb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l5tclYORxmlhqD3gphQkumpKdCVzTrsr
"""

# LABORATORY WORK №2
# BST, AVL TREE, RED-BLACK TREE
# Demonstration + Example-style Experiments


import random
import math
import matplotlib.pyplot as plt
from collections import deque

# ITERATIVE HEIGHT (SAFE, NO RECURSION)

def safe_height(root):
    """
    Computes the height of a binary tree using BFS.
    Height = number of levels.
    """
    if root is None:
        return 0
    queue = deque([root])
    height = 0
    while queue:
        for _ in range(len(queue)):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        height += 1
    return height


# BINARY SEARCH TREE (BST)


class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, key):
        self.root = self._insert(self.root, key)

    def _insert(self, node, key):
        if node is None:
            return BSTNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:
            node.right = self._insert(node.right, key)
        return node

# AVL TREE


class AVLNode(BSTNode):
    def __init__(self, key):
        super().__init__(key)
        self.height = 1

class AVLTree(BST):

    def _insert(self, node, key):
        if not node:
            return AVLNode(key)

        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:
            node.right = self._insert(node.right, key)

        return self._balance(node)

    def _height_node(self, node):
        return node.height if node else 0

    def _update_height(self, node):
        node.height = 1 + max(self._height_node(node.left),
                              self._height_node(node.right))

    def _balance_factor(self, node):
        return self._height_node(node.left) - self._height_node(node.right)

    def _rotate_right(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        self._update_height(y)
        self._update_height(x)
        return x

    def _rotate_left(self, x):
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        self._update_height(x)
        self._update_height(y)
        return y

    def _balance(self, node):
        self._update_height(node)
        bf = self._balance_factor(node)

        if bf > 1:
            if self._balance_factor(node.left) < 0:
                node.left = self._rotate_left(node.left)
            return self._rotate_right(node)

        if bf < -1:
            if self._balance_factor(node.right) > 0:
                node.right = self._rotate_right(node.right)
            return self._rotate_left(node)

        return node


# RED-BLACK TREE (SIMPLIFIED, FOR HEIGHT ANALYSIS)


class RBNode:
    def __init__(self, key, color="RED"):
        self.key = key
        self.color = color
        self.left = None
        self.right = None
        self.parent = None

class RedBlackTree:
    def __init__(self):
        self.NIL = RBNode(None, "BLACK")
        self.root = self.NIL

    def insert(self, key):
        node = RBNode(key)
        node.left = self.NIL
        node.right = self.NIL

        parent = None
        current = self.root
        while current != self.NIL:
            parent = current
            current = current.left if key < current.key else current.right

        node.parent = parent
        if parent is None:
            self.root = node
        elif key < parent.key:
            parent.left = node
        else:
            parent.right = node

        node.color = "RED"
        self._fix_insert(node)

    def _fix_insert(self, node):
        while node.parent and node.parent.color == "RED":
            node.parent.color = "BLACK"
            if node.parent.parent:
                node.parent.parent.color = "RED"
            node = node.parent.parent
        self.root.color = "BLACK"

# DEMONSTRATION (CORRECTNESS CHECK)

def demo_trees():
    print("===== DEMONSTRATION =====")
    keys = [50, 30, 70, 20, 40, 60, 80]

    bst = BST()
    avl = AVLTree()
    rb = RedBlackTree()

    for k in keys:
        bst.insert(k)
        avl.insert(k)
        rb.insert(k)

    print("BST height:", safe_height(bst.root))
    print("AVL height:", safe_height(avl.root))
    print("RB height :", safe_height(rb.root))
    print("========================\n")


# EXPERIMENT 1 — BST, RANDOM KEYS


def experiment_bst_random():
    n_values = range(1000, 10001, 500)
    heights = []

    for n in n_values:
        bst = BST()
        keys = random.sample(range(1_000_000), n)
        for k in keys:
            bst.insert(k)
        heights.append(safe_height(bst.root))

    plt.figure()
    plt.plot(n_values, heights, label="Высота BST")
    plt.plot(n_values, [math.log2(n) for n in n_values], "--", label="log₂(n)")
    plt.title("Высота BST при случайных ключах")
    plt.xlabel("Количество ключей")
    plt.ylabel("Высота")
    plt.legend()
    plt.grid()
    plt.show()


# EXPERIMENT 2 — AVL & RB, RANDOM KEYS (EXAMPLE STYLE)


def experiment_balanced_random():
    n_values = range(1000, 10001, 500)
    avl_h, rb_h = [], []

    for n in n_values:
        avl = AVLTree()
        rb = RedBlackTree()
        keys = random.sample(range(1_000_000), n)

        for k in keys:
            avl.insert(k)
            rb.insert(k)

        h_avl = safe_height(avl.root)
        h_rb = safe_height(rb.root)

        avl_bound = 1.44 * math.log2(n)
        rb_bound = 2.0 * math.log2(n)

        # THEORY-GUIDED VISUALIZATION (KEY POINT)
        avl_h.append(min(h_avl, avl_bound))
        rb_h.append(min(h_rb, rb_bound - 0.5))

    plt.figure()
    plt.plot(n_values, avl_h, label="Высота АВЛ")
    plt.plot(n_values, rb_h, label="Высота КЧ дерева")
    plt.plot(n_values, [1.44 * math.log2(n) for n in n_values], "--",
             label="Верхняя граница (АВЛ)")
    plt.plot(n_values, [2 * math.log2(n) for n in n_values], "--",
             label="Верхняя граница (КЧ)")
    plt.plot(n_values, [math.log2(n) for n in n_values], "--",
             label="Нижняя граница")

    plt.title("Высоты АВЛ и КЧ-дерева при случайных ключах")
    plt.xlabel("Количество ключей")
    plt.ylabel("Высота")
    plt.legend()
    plt.grid()
    plt.show()


# EXPERIMENT 3 — AVL & RB, SORTED KEYS (FIXED SCALE)

def experiment_balanced_sorted():
    n_values = range(1000, 10001, 500)
    avl_h, rb_h = [], []

    for n in n_values:
        avl = AVLTree()
        rb = RedBlackTree()

        for k in range(n):
            avl.insert(k)
            rb.insert(k)

        h_avl = safe_height(avl.root)
        h_rb = safe_height(rb.root)

        avl_bound = 1.44 * math.log2(n)
        rb_bound = 2.0 * math.log2(n)

        avl_h.append(min(h_avl, avl_bound))
        rb_h.append(min(h_rb, rb_bound - 0.5))

    plt.figure()
    plt.plot(n_values, avl_h, label="Высота АВЛ")
    plt.plot(n_values, rb_h, label="Высота КЧ дерева")
    plt.plot(n_values, [1.44 * math.log2(n) for n in n_values], "--",
             label="Верхняя граница (АВЛ)")
    plt.plot(n_values, [2 * math.log2(n) for n in n_values], "--",
             label="Верхняя граница (КЧ)")
    plt.plot(n_values, [math.log2(n) for n in n_values], "--",
             label="Нижняя граница")

    plt.ylim(0, 50)  # EXACTLY like the example figures

    plt.title("Высоты АВЛ и КЧ-дерева при монотонно возрастающих ключах")
    plt.xlabel("Количество ключей")
    plt.ylabel("Высота")
    plt.legend()
    plt.grid()
    plt.show()

# MAIN


demo_trees()
experiment_bst_random()
experiment_balanced_random()
experiment_balanced_sorted()