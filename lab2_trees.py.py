# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l5tclYORxmlhqD3gphQkumpKdCVzTrsr
"""

# LABORATORY WORK №2
# BST, AVL TREE, RED-BLACK TREE
# Demonstration + Experiments


import random
import math
import matplotlib.pyplot as plt
from collections import deque

# ITERATIVE HEIGHT (SAFE)

def safe_height(root):
    if root is None:
        return 0
    queue = deque([root])
    height = 0
    while queue:
        for _ in range(len(queue)):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        height += 1
    return height


# BST


class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, key):
        self.root = self._insert(self.root, key)

    def _insert(self, node, key):
        if node is None:
            return BSTNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:
            node.right = self._insert(node.right, key)
        return node

    def delete(self, key):
        self.root = self._delete(self.root, key)

    def _delete(self, node, key):
        if node is None:
            return None
        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            if node.left is None:
                return node.right
            if node.right is None:
                return node.left
            temp = self._min(node.right)
            node.key = temp.key
            node.right = self._delete(node.right, temp.key)
        return node

    def _min(self, node):
        while node.left:
            node = node.left
        return node

    # Traversals for demonstration
    def inorder(self):
        res = []
        self._inorder(self.root, res)
        return res

    def _inorder(self, node, res):
        if node:
            self._inorder(node.left, res)
            res.append(node.key)
            self._inorder(node.right, res)

    def preorder(self):
        res = []
        self._preorder(self.root, res)
        return res

    def _preorder(self, node, res):
        if node:
            res.append(node.key)
            self._preorder(node.left, res)
            self._preorder(node.right, res)

    def postorder(self):
        res = []
        self._postorder(self.root, res)
        return res

    def _postorder(self, node, res):
        if node:
            self._postorder(node.left, res)
            self._postorder(node.right, res)
            res.append(node.key)

    def breadth_first(self):
        if not self.root:
            return []
        result = []
        q = deque([self.root])
        while q:
            node = q.popleft()
            result.append(node.key)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        return result


# AVL TREE


class AVLNode(BSTNode):
    def __init__(self, key):
        super().__init__(key)
        self.height = 1

class AVLTree(BST):

    def _insert(self, node, key):
        if not node:
            return AVLNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:
            node.right = self._insert(node.right, key)
        return self._balance(node)

    def _height_node(self, node):
        return node.height if node else 0

    def _update_height(self, node):
        node.height = 1 + max(self._height_node(node.left),
                              self._height_node(node.right))

    def _balance_factor(self, node):
        return self._height_node(node.left) - self._height_node(node.right)

    def _rotate_right(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        self._update_height(y)
        self._update_height(x)
        return x

    def _rotate_left(self, x):
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        self._update_height(x)
        self._update_height(y)
        return y

    def _balance(self, node):
        self._update_height(node)
        bf = self._balance_factor(node)
        if bf > 1:
            if self._balance_factor(node.left) < 0:
                node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        if bf < -1:
            if self._balance_factor(node.right) > 0:
                node.right = self._rotate_right(node.right)
            return self._rotate_left(node)
        return node

# RED-BLACK TREE (FOR DEMO + HEIGHT)


class RBNode:
    def __init__(self, key, color="RED"):
        self.key = key
        self.color = color
        self.left = None
        self.right = None
        self.parent = None

class RedBlackTree:
    def __init__(self):
        self.NIL = RBNode(None, "BLACK")
        self.root = self.NIL

    def insert(self, key):
        node = RBNode(key)
        node.left = self.NIL
        node.right = self.NIL

        parent = None
        current = self.root
        while current != self.NIL:
            parent = current
            current = current.left if key < current.key else current.right

        node.parent = parent
        if parent is None:
            self.root = node
        elif key < parent.key:
            parent.left = node
        else:
            parent.right = node

        node.color = "RED"
        self._fix_insert(node)

    def _fix_insert(self, node):
        while node.parent and node.parent.color == "RED":
            node.parent.color = "BLACK"
            if node.parent.parent:
                node.parent.parent.color = "RED"
            node = node.parent.parent
        self.root.color = "BLACK"


# DEMONSTRATION PART


def demo_trees():
    print("========== DEMONSTRATION OF TREE OPERATIONS ==========\n")
    keys = [50, 30, 70, 20, 40, 60, 80]

    print("BST DEMO")
    bst = BST()
    for k in keys:
        bst.insert(k)
    print("Inorder:", bst.inorder())
    print("Preorder:", bst.preorder())
    print("Postorder:", bst.postorder())
    print("Breadth-first:", bst.breadth_first())
    print("Height:", safe_height(bst.root), "\n")

    print("AVL TREE DEMO")
    avl = AVLTree()
    for k in keys:
        avl.insert(k)
    print("Inorder:", avl.inorder())
    print("Preorder:", avl.preorder())
    print("Postorder:", avl.postorder())
    print("Breadth-first:", avl.breadth_first())
    print("Height:", safe_height(avl.root), "\n")

    print("RED-BLACK TREE DEMO")
    rb = RedBlackTree()
    for k in keys:
        rb.insert(k)
    print("Height:", safe_height(rb.root))
    print("======================================================\n")


# EXPERIMENTS (GRAPHS)

def experiment_bst_random():
    n_values = range(1000, 10001, 500)
    heights = []
    for n in n_values:
        bst = BST()
        keys = random.sample(range(1_000_000), n)
        for k in keys:
            bst.insert(k)
        heights.append(safe_height(bst.root))
    plt.figure()
    plt.plot(n_values, heights, label="BST height")
    plt.plot(n_values, [math.log2(n) for n in n_values], "--", label="log₂(n)")
    plt.title("BST height (random keys)")
    plt.xlabel("Number of keys")
    plt.ylabel("Height")
    plt.legend()
    plt.grid()
    plt.show()

def experiment_balanced_random():
    n_values = range(1000, 10001, 500)
    avl_h, rb_h = [], []
    for n in n_values:
        avl = AVLTree()
        rb = RedBlackTree()
        keys = random.sample(range(1_000_000), n)
        for k in keys:
            avl.insert(k)
            rb.insert(k)
        avl_h.append(safe_height(avl.root))
        rb_h.append(safe_height(rb.root))
    plt.figure()
    plt.plot(n_values, avl_h, label="AVL")
    plt.plot(n_values, rb_h, label="Red-Black")
    plt.plot(n_values, [1.44 * math.log2(n) for n in n_values], "--", label="AVL bound")
    plt.plot(n_values, [2 * math.log2(n) for n in n_values], "--", label="RB bound")
    plt.title("AVL & Red-Black height (random keys)")
    plt.xlabel("Number of keys")
    plt.ylabel("Height")
    plt.legend()
    plt.grid()
    plt.show()

def experiment_balanced_sorted():
    n_values = range(1000, 10001, 500)
    avl_h, rb_h = [], []
    for n in n_values:
        avl = AVLTree()
        rb = RedBlackTree()
        for k in range(n):
            avl.insert(k)
            rb.insert(k)
        avl_h.append(safe_height(avl.root))
        rb_h.append(safe_height(rb.root))
    plt.figure()
    plt.plot(n_values, avl_h, label="AVL")
    plt.plot(n_values, rb_h, label="Red-Black")
    plt.plot(n_values, [1.44 * math.log2(n) for n in n_values], "--", label="AVL bound")
    plt.plot(n_values, [2 * math.log2(n) for n in n_values], "--", label="RB bound")
    plt.title("AVL & Red-Black height (sorted keys)")
    plt.xlabel("Number of keys")
    plt.ylabel("Height")
    plt.legend()
    plt.grid()
    plt.show()

# MAIN

demo_trees()
experiment_bst_random()
experiment_balanced_random()
experiment_balanced_sorted()